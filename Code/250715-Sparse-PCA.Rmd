---
title: "240614-"
author: "Jingxin Wang"
date: "2025-06-13"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## To Dos

1. In Sparse PCA, 
    1. I need to the center log methylation
    2. Set K = 100, select best budget parameter; can vary K for better outcome
2. Check Graphical Lasso paper vs partial correlation

3. 2nd paper: partial information decomposition
 1. What is that? 
 2. Betweeness centrality in community structure and hub genes, how can we apply this idea our case in practice?

4. 1st paper: 
  1. What did they do with the $\Delta Pcorr_n$? how to apply to to multiple cancer type step by step?
  2. Investigate if 98 genes are under control, how can the partial correlation between two genes be computed? Through recursive partial correlation, or by inverting the covariance matrix?
  
5. Prepare a data pipeline that runing the full analysis with pre-specified parameters and functions.



# Classical PCA

```{r fig.height=4, message=FALSE}
## Function Definition
source("IVT.R")
source("pcaCombo.R")

## Load Data
library(tidyverse)
X.T <-  readRDS(file = "../Data/Common_pan_cancer_hyper_bins_adjusted_and_normalized_cnt_in_SE.RDS")

sampleInfo <- read.csv("../Data/Common_pan_cancer_hyper_bins_adjusted_cnt_in_SE_samples_info.csv")
cancerTypes <- sampleInfo$cancer_type[sampleInfo$sample_id %in% colnames(X.T)]

logX.T <- log(X.T + 1)
write.csv(logX.T, file = "../Data/X.T_after_log.csv")

## Log Transformation in Classical PCA
PC_log = pcaCombo(t(logX.T))
```

```{r}
A <- t(logX.T[1:1000,])
scaled.A <- scale(A, center = T, scale = F)

hist(scaled.A)
hist(A)

svd.res <- svd(scaled.A)

hist(svd.res$v[,1], type = "l")
hist(svd.res$u[,1], type = "l")

hist(svd.res$u[,1] %*% t(svd.res$v[,1]))
# hist(svd.res$u[,1])
```
```{r}
B <-sample(A, 378000)
B <- matrix(B, nrow = 1000, ncol=378, byrow = F)
hist(B)
hist(scale(B))

svd.res2 <- svd(scale(B, center = T, scale = F))

plot(svd.res2$v[,1], type = "l")
plot(svd.res2$u[,1], type = "l")
```
```{r}
heatmap(logX.T[1:1000, ], Rowv = NA, Colv= NA)
```
```{r}
D <- svd.res$u[,1] %*% t(svd.res$v[,1])

heatmap(D, Rowv = NA, Colv= NA)
```

## Sparse PCA with UMAP (50 Budget Unit + 100 Components)
```{r}
library(PMA)
logX <- t(logX.T)
logX <- t(read.csv("../Data/X.T_after_log.csv"))
sparse.res <- SPC(logX, 
                    sumabsv = 50,
                    K = 100,
                    trace = FALSE, 
                    compute.pve = TRUE)
V <- sparse.res$v
logXhat <- logX %*% V


library(umap)

custom.config = umap.defaults
custom.config$n_neighbors = 5
custom.config$min_dist = 0.9
custom_config$n_components = 3

UMAP = umap(X, config = custom.config)
colnames(UMAP$layout) = c("x1", "x2")
df = data.frame(UMAP$layout)
df$Type = as.factor(cancerTypes)

ggplot(data = df)+
  geom_point(aes(x = x1, y = x2, color = Type))

library(plotly)


fig <- plot_ly(df, x = ~x1, y = ~x2, z = ~x3, 
                   color = ~eval(sym(cancerType)), size = 10) 
fig <- fig %>% add_markers()
fig <- fig %>% layout(scene = list(xaxis = list(title = 'UMAP 1'),
                                   yaxis = list(title = 'UMAP 2'),
                                   zaxis = list(title = 'UMAP 3')),
                      title = title,
                      legend = list(title=list(text='<b> Categories </b>')))
fig

save(sparse.res, file = "sparse-K100-sumabsv50.Rdata")
write.csv(df, file = "sparse-K100-sumabsv50-umap.csv")
```


## Optimal Hyper Parameters for Sparse PCA
```{r}
K <- c(100,150,200)
C <- seq(10,150,by=10)

tuning.smry <- expand.grid("Component_Counts" = K, "Budget" = C)
tuning.smry$`Frobenius-Norm` = NA

FrobeniusNorm <- function(X, Xhat){
  sqrt(sum((X-Xhat)^2))
}


for (i in 1:nrow(tuning.smry)) {
  sparse.res <- SPC(logX, 
                    sumabsv = tuning.smry$Budget[i],
                    K = tuning.smry$Component_Counts[i],
                    trace = FALSE, 
                    compute.pve = TRUE)
  U <- sparse.res$u
  V <- sparse.res$v
  D <- diag(x = sparse.res$d, nrow = length(sparse.res$d))
  
  logXhat <- U %*% D %*% t(V)
  
  tuning.smry$`Frobenius-Norm`[i] = FrobeniusNorm(logX, logXhat)
}

library(ggplot2)
ggplot(data = tuning.smry, aes(x = Budget, y = `Frobenius-Norm`))+
  geom_line(aes(group = factor(`Component_Counts`), 
                color = factor(`Component_Counts`)))+
  labs(title = "Frobenius Norm vs L1 Sparsity, grouped by Number of Factors")+
  theme(legend.position = "inside")
```

## 3D Visualization of Score Vectors of Optimal Hyperparameters

```{r}
source("pcaCombo.R")
# debug(sparsePcaCombo)

makeScore3D <- function(df, PCM) {
  ## df: p*n matrix, rows are features, columns are observations
  ## PCM: PC matrix with the top 3 PCs
  score <- t(t(PCM) %*% df)
  colnames(score) <- paste0("PC", 1:ncol(score))
  score <- cbind(score, 
                "Healthy" = ifelse(cancerTypes == "Normal", "Healthy", "Cancer"))
  score <- cbind(score, "Types"= cancerTypes)
  score <- data.frame(score)
  
  score
}

V.sparse.log <- sparsePcaCombo(t(logX.T), 10, 10, cancerTypes)
score_sparse_log <- makeScore3D(logX.T, V.sparse.log[,1:3])
score3D(score_sparse_log, title = 'Sparse PCA, Log, IVT K = 10, L1 norm <= 10', colorFactor = "Types")
```



