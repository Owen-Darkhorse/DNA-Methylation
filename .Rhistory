l <- L(w) ## Laplacian
u <- bottomK(l, K) ## Eigen values
clustVec <- KM(u, K)
## Plot first two eigenvectors, colored by cluster
library(ggplot2)
U2 <- data.frame(cbind(u[,1:2], clustVec))
colnames(U2) <- c("U1",  "U2", "C")
browser()
# ggplot(U2) +
#   geom_point(aes(U1, U2, color = factor(C))) +
#   xlab("U1") +
#   ylab("U2") +
#   ggtitle("Clustering of genes in the the first two eigenvectors' space")
A <- plot(U2[,1], U2[,2], col = factor(clustVec),
main = "Clustering of genes in the the first two eigenvectors' space",
xlab = "U1", ylab = "U2")
## Plot Grpah Rrepresentation
library(igraph)
G = graph_from_adjacency_matrix(w, mode="undirected", weighted = TRUE)
layout_circle <- layout_in_circle(G)
B <- plot(G, vertex.size=3, vertex.label=NA,
layout = layout_circle)
cowplot::plot_grid(plotlist = list(A,B),
nrow = 1, ncol = 2,
labels = c("A", "B"))
clustVec
}
sClusters <- spectralClust(X, 3)
View(cancerFrameList)
for (cancer in names(cancerFrameList)) {
cat("Cancer type": cancer, "\n")
X <- t(cancerFrameList[[cancer]])
sClusters <- spectralClust(X, 3)
}
for (cancer in names(cancerFrameList)) {
cat("Cancer type:" cancer, "\n")
paste("Cancer type:" cancer, "\n")
paste("Cancer type:", "Bladder", "\n")
for (cancer in names(cancerFrameList)) {
paste("Cancer type:", cancer, "\n")
X <- t(cancerFrameList[[cancer]])
sClusters <- spectralClust(X, 3)
}
## Wrapper Function
spectralClust <- function(X, K, extra = NA) {
s <- S(X) ## Similarity
w <- W(s, "Full", extra) ## Weight
l <- L(w) ## Laplacian
u <- bottomK(l, K) ## Eigen values
clustVec <- KM(u, K)
## Plot first two eigenvectors, colored by cluster
library(ggplot2)
U2 <- data.frame(cbind(u[,1:2], clustVec))
colnames(U2) <- c("U1",  "U2", "C")
# ggplot(U2) +
#   geom_point(aes(U1, U2, color = factor(C))) +
#   xlab("U1") +
#   ylab("U2") +
#   ggtitle("Clustering of genes in the the first two eigenvectors' space")
A <- plot(U2[,1], U2[,2], col = factor(clustVec),
main = "Clustering of genes in the the first two eigenvectors' space",
xlab = "U1", ylab = "U2")
## Plot Grpah Rrepresentation
library(igraph)
G = graph_from_adjacency_matrix(w, mode="undirected", weighted = TRUE)
layout_circle <- layout_in_circle(G)
B <- plot(G, vertex.size=3, vertex.label=NA,
layout = layout_circle)
cowplot::plot_grid(plotlist = list(A,B),
nrow = 1, ncol = 2,
labels = c("A", "B"))
clustVec
}
cancerFrameList <- split(data.frame(t(X)), cancerTypes)
for (cancer in names(cancerFrameList)) {
paste("Cancer type:", cancer, "\n")
X <- t(cancerFrameList[[cancer]])
sClusters <- spectralClust(X, 3)
}
## Wrapper Function
spectralClust <- function(X, K, extra = NA) {
s <- S(X) ## Similarity
w <- W(s, "Full", extra) ## Weight
l <- L(w) ## Laplacian
u <- bottomK(l, K) ## Eigen values
clustVec <- KM(u, K)
## Plot first two eigenvectors, colored by cluster
library(ggplot2)
U2 <- data.frame(cbind(u[,1:2], clustVec))
colnames(U2) <- c("U1",  "U2", "C")
# ggplot(U2) +
#   geom_point(aes(U1, U2, color = factor(C))) +
#   xlab("U1") +
#   ylab("U2") +
#   ggtitle("Clustering of genes in the the first two eigenvectors' space")
A <- plot(U2[,1], U2[,2], col = factor(clustVec),
main = "Clustering of genes in the the first two eigenvectors' space",
xlab = "U1", ylab = "U2")
## Plot Grpah Rrepresentation
library(igraph)
G = graph_from_adjacency_matrix(w, mode="undirected", weighted = TRUE)
layout_circle <- layout_in_circle(G)
B <- plot(G, vertex.size=3, vertex.label=NA,
layout = layout_circle)
cowplot::plot_grid(plotlist = list(A,B),
nrow = 1, ncol = 2,
labels = c("A", "B"))
clustVec
}
cancerFrameList <- split(data.frame(t(X)), cancerTypes)
for (cancer in names(cancerFrameList)) {
paste("Cancer type:", cancer, "\n")
X <- t(cancerFrameList[[cancer]])
sClusters <- spectralClust(X, 3)
}
## Wrapper Function
spectralClust <- function(X, K, extra = NA) {
s <- S(X) ## Similarity
w <- W(s, "Full", extra) ## Weight
l <- L(w) ## Laplacian
u <- bottomK(l, K) ## Eigen values
clustVec <- KM(u, K)
par(mfrow = c(1,2))
## Plot first two eigenvectors, colored by cluster
library(ggplot2)
U2 <- data.frame(cbind(u[,1:2], clustVec))
colnames(U2) <- c("U1",  "U2", "C")
# ggplot(U2) +
#   geom_point(aes(U1, U2, color = factor(C))) +
#   xlab("U1") +
#   ylab("U2") +
#   ggtitle("Clustering of genes in the the first two eigenvectors' space")
plot(U2[,1], U2[,2], col = factor(clustVec),
main = "Clustering of genes in the the first two eigenvectors' space",
xlab = "U1", ylab = "U2")
## Plot Grpah Rrepresentation
library(igraph)
G = graph_from_adjacency_matrix(w, mode="undirected", weighted = TRUE)
layout_circle <- layout_in_circle(G)
plot(G, vertex.size=3, vertex.label=NA,
layout = layout_circle)
clustVec
}
library(tidyverse)
seCount <-  readRDS(file = "Common_pan_cancer_hyper_bins_adjusted_and_normalized_cnt_in_SE.RDS")
dim(seCount)
sampleInfo <- read.csv("Common_pan_cancer_hyper_bins_adjusted_cnt_in_SE_samples_info.csv")
cancerTypes <- sampleInfo$cancer_type[sampleInfo$sample_id %in% colnames(seCount)]
## Load gene numbers that are important in PCA
load("impGenes.RData")
X <- seCount[impGenes, ]
debug(spectralClust)
sClusters <- spectralClust(X, 3)
cancerFrameList <- split(data.frame(t(X)), cancerTypes)
for (cancer in names(cancerFrameList)) {
paste("Cancer type:", cancer, "\n")
X <- t(cancerFrameList[[cancer]])
sClusters <- spectralClust(X, 3)
}
c
c
?dist
## Wrapper Function
spectralClust <- function(X, K, cancerType = "All", extra = NA) {
s <- S(X) ## Similarity
w <- W(s, "Full", extra) ## Weight
l <- L(w) ## Laplacian
u <- bottomK(l, K) ## Eigen values
clustVec <- KM(u, K)
par(mfrow = c(1,2))
## Plot first two eigenvectors, colored by cluster
library(ggplot2)
U2 <- data.frame(cbind(u[,1:2], clustVec))
colnames(U2) <- c("U1",  "U2", "C")
plot(U2[,1], U2[,2], col = factor(clustVec),
main = "Clustering in top 2 eigenvectors",
xlab = "U1", ylab = "U2")
## Plot Grpah Rrepresentation
library(igraph)
G = graph_from_adjacency_matrix(w, mode="undirected", weighted = TRUE)
layout_circle <- layout_in_circle(G)
plot(G, vertex.size=3, vertex.label=NA,
layout = layout_circle,
main = paste("Spectral Graph for ", cancerType))
mtext(cancerType,
side = 3, line = -2, outer = TRUE, cex = 1.5)
clustVec
}
load("impGenes.RData")
X <- seCount[impGenes, ]
sClusters <- spectralClust(X, 3, "All")
cancerFrameList <- split(data.frame(t(X)), cancerTypes)
for (cancer in names(cancerFrameList)) {
paste("Cancer type:", cancer, "\n")
X <- t(cancerFrameList[[cancer]])
sClusters <- spectralClust(X, 3, cancer)
}
## Wrapper Function
spectralClust <- function(X, K, cancerType = "All", extra = NA) {
s <- S(X) ## Similarity
w <- W(s, "Full", extra) ## Weight
l <- L(w) ## Laplacian
u <- bottomK(l, K) ## Eigen values
clustVec <- KM(u, K)
par(mfrow = c(1,2))
## Plot first two eigenvectors, colored by cluster
library(ggplot2)
U2 <- data.frame(cbind(u[,1:2], clustVec))
colnames(U2) <- c("U1",  "U2", "C")
plot(U2[,1], U2[,2], col = factor(clustVec),
main = "Clustering in top 2 eigenvectors",
xlab = "U1", ylab = "U2")
## Plot Grpah Rrepresentation
library(igraph)
G = graph_from_adjacency_matrix(w, mode="undirected", weighted = TRUE)
layout_circle <- layout_in_circle(G)
plot(G, vertex.size=3, vertex.label=NA,
layout = layout_circle,
main = paste("Spectral Graph for ", cancerType))
mtext(cancerType,
side = 3, line = -2, outer = TRUE, cex = 1.5)
list("clustVec" = clustVec,
"G" = G)
}
## Generate Data
set.seed(226)
n = 100
r1 = 0.3
r2 = 1
r3 = 1.8
X1 = matrix(rnorm(n * 2), n, 2)
X1 = X1/sqrt(rowSums(X1^2)) * r1
X2 = matrix(rnorm(n * 2), n, 2)
X2 = X2/sqrt(rowSums(X2^2)) * r2
X3 = matrix(rnorm(n * 2), n, 2)
X3 = X3/sqrt(rowSums(X3^2)) * r3
E = matrix(rnorm(3*n * 2, 0, 0.1), 3*n, 2)
X = rbind(X1, X2, X3) + E
X = scale (X, scale = F, center = T)
colnames(X) = c("x1", "x2")
K <- 3
specClusters <- spectralClust(X, K, "All")
ggplot(cbind(X, "C" = specClusters$clustVec)) +
geom_point(aes(x1, x2, color = factor(C))) +
xlab("X1") +
ylab("X2") +
ggtitle("Clustering of genes in the the first two eigenvectors' space")
X <- seCount[impGenes, ]
sClusters <- spectralClust(X, 3, "All")
graphAll <- sClusters$G
?plot.graph
?graph_from_adjacency_matrix
cancerFrameList <- split(data.frame(t(X)), cancerTypes)
commonGraph <- NULL
## Compute the Intersection of all graphs
for (cancer in names(cancerFrameList)) {
paste("Cancer type:", cancer, "\n")
X <- t(cancerFrameList[[cancer]])
sClusters <- spectralClust(X, 3, cancer)
if (is.null(commonGraph)) {
commonGraph <- sClusters$G
} else {
commonGraph <- intersection(commonGraph, sClusters$G)
}
}
plot(commonGraph, vertex.size=3, vertex.label=NA,
layout = layout_circle,
main = "Common Graph of All Cancer Types")
cancerFrameList <- split(data.frame(t(X)), cancerTypes)
commonGraph <- NULL
## Compute the Intersection of all graphs
for (cancer in names(cancerFrameList)) {
paste("Cancer type:", cancer, "\n")
X <- t(cancerFrameList[[cancer]])
sClusters <- spectralClust(X, 3, cancer)
if (is.null(commonGraph)) {
commonGraph <- sClusters$G
} else {
commonGraph <- intersection(commonGraph, sClusters$G)
}
}
## Plot common graph
layout_circle <- layout_in_circle(commonGraph)
plot(commonGraph, vertex.size=3, vertex.label=NA,
layout = layout_circle,
main = "Common Graph of All Cancer Types")
X <- seCount[impGenes, ]
cancerFrameList <- split(data.frame(t(X)), cancerTypes)
commonGraph <- NULL
## Compute the Intersection of all graphs
for (cancer in names(cancerFrameList)) {
paste("Cancer type:", cancer, "\n")
X <- t(cancerFrameList[[cancer]])
sClusters <- spectralClust(X, 3, cancer)
if (is.null(commonGraph)) {
commonGraph <- sClusters$G
} else {
commonGraph <- intersection(commonGraph, sClusters$G)
}
}
## Plot common graph
layout_circle <- layout_in_circle(commonGraph)
plot(commonGraph, vertex.size=3, vertex.label=NA,
layout = layout_circle,
main = "Common Graph of All Cancer Types")
commonGraph
pmin
?pmin
?E()
E(commonGraph)$weight <- pmin(E(commonGraph)$weight, E(sClusters$G)$weight)
layout_circle <- layout_in_circle(commonGraph)
plot(commonGraph, vertex.size=3, vertex.label=NA,
layout = layout_circle,
main = "Common Graph of All Cancer Types")
X <- seCount[impGenes, ]
cancerFrameList <- split(data.frame(t(X)), cancerTypes)
commonGraph <- NULL
## Compute the Intersection of all graphs
for (cancer in names(cancerFrameList)) {
paste("Cancer type:", cancer, "\n")
X <- t(cancerFrameList[[cancer]])
sClusters <- spectralClust(X, 3, cancer)
if (is.null(commonGraph)) {
commonGraph <- sClusters$G
} else {
E(commonGraph)$weight <- pmin(E(commonGraph)$weight, E(sClusters$G)$weight)
}
}
for (cancer in names(cancerFrameList)) {
paste("Cancer type:", cancer, "\n")
X <- t(cancerFrameList[[cancer]])
sClusters <- spectralClust(X, 3, cancer)
if (is.null(commonGraph)) {
commonGraph <- sClusters$G
} else {
E(commonGraph)$weight <- pmin(E(commonGraph)$weight, E(sClusters$G)$weight)
}
}
pmin(E(commonGraph)$weight, E(sClusters$G)$weight)
E(commonGraph)$weight <- pmin(E(commonGraph)$weight, E(sClusters$G)$weight)
pmin(E(commonGraph)$weight, E(sClusters$G)$weight)
E(commonGraph)$weight
?graph_from_adjacency_matrix()
layout_circle <- layout_in_circle(commonGraph)
plot(commonGraph, vertex.size=3, vertex.label=NA,
layout = layout_circle,
main = "Common Graph of All Cancer Types")
for (cancer in names(cancerFrameList)) {
paste("Cancer type:", cancer, "\n")
X <- t(cancerFrameList[[cancer]])
sClusters <- spectralClust(X, 3, cancer)
if (is.null(commonGraph)) {
commonGraph <- sClusters$G
} else {
commonGraph <- intersection(commonGraph, sClusters$G)
E(commonGraph)$weight <- pmin(E(commonGraph)$weight, E(sClusters$G)$weight)
}
}
for (cancer in names(cancerFrameList)) {
paste("Cancer type:", cancer, "\n")
X <- t(cancerFrameList[[cancer]])
sClusters <- spectralClust(X, 3, cancer)
if (is.null(commonGraph)) {
commonGraph <- sClusters$G
} else {
commonGraph <- intersection(commonGraph, sClusters$G)
# E(commonGraph)$weight <- pmin(E(commonGraph)$weight, E(sClusters$G)$weight)
}
}
layout_circle <- layout_in_circle(commonGraph)
plot(commonGraph, vertex.size=3, vertex.label=NA,
layout = layout_circle,
main = "Common Graph of All Cancer Types")
cancerFrameList <- split(data.frame(t(X)), cancerTypes)
commonGraph <- NULL
## Compute the Intersection of all graphs
for (cancer in names(cancerFrameList)) {
paste("Cancer type:", cancer, "\n")
X <- t(cancerFrameList[[cancer]])
sClusters <- spectralClust(X, 3, cancer)
if (is.null(commonGraph)) {
commonGraph <- sClusters$G
} else {
commonGraph <- intersection(commonGraph, sClusters$G)
# E(commonGraph)$weight <- pmin(E(commonGraph)$weight, E(sClusters$G)$weight)
}
}
## Plot common graph
layout_circle <- layout_in_circle(commonGraph)
plot(commonGraph, vertex.size=3, vertex.label=NA,
layout = layout_circle,
main = "Common Graph of All Cancer Types")
knitr::opts_chunk$set(echo = TRUE)
seCount <-  readRDS(file = "Common_pan_cancer_hyper_bins_adjusted_and_normalized_cnt_in_SE.RDS")
dim(seCount)
sampleInfo <- read.csv("Common_pan_cancer_hyper_bins_adjusted_cnt_in_SE_samples_info.csv")
cancerTypes <- sampleInfo$cancer_type[sampleInfo$sample_id %in% colnames(seCount)]
## Load gene numbers that are important in PCA
load("impGenes.RData")
X <- t(seCount[impGenes, ])
## First try predicting any cancer, regardless of types
y <- ifelse(cancerTypes != "Normal", 1, 0)
library(CVXR)
## Decision Variables
p <- length(impGenes)
beta <- Variable(p)
## Logistic Loss Function
binomLoss <- -(
sum(X[y == 1, ] %*% beta) +
sum(logistic(-X %*% beta))
)
## Penalty Function
pairwise_penalty <- function(beta, lambda_1 = 1, lambda_2 = 1) {
L1 <- p_norm(beta, 1) * lambda_1
p <- length(beta)
pair_indices <- combn(2, p, simplify = FALSE)
# Create penalty matrix: each row enforces β_j - β_k
penalty_matrix <- do.call(rbind, lapply(pair_indices, function(idx) {
vec <- rep(0, p)
vec[idx[1]] <- 1
vec[idx[2]] <- -1
vec
}))
fusionPenalty <- sum(abs(penalty_matrix %*% beta)) * lambda_2
L1 + fusionPenalty
}
## Problem Formulation
lambda_1 <- 1
lambda_2 <- 1
obj <- binomLoss + pairwise_penalty(beta, lambda_1, lambda_2)
## Penalty Function
pairwise_penalty <- function(beta, lambda_1 = 1, lambda_2 = 1) {
L1 <- p_norm(beta, 1) * lambda_1
p <- length(beta)
pair_indices <- combn(2, p, simplify = FALSE)
browser()
# Create penalty matrix: each row enforces β_j - β_k
penalty_matrix <- do.call(rbind, lapply(pair_indices, function(idx) {
vec <- rep(0, p)
vec[idx[1]] <- 1
vec[idx[2]] <- -1
vec
}))
fusionPenalty <- sum(abs(penalty_matrix %*% beta)) * lambda_2
L1 + fusionPenalty
}
pairwise_penalty(beta, lambda_1, lambda_2)
combn(2, p, simplify = FALSE)
combn(p, 2, simplify = FALSE)
p
beta@dim
## Penalty Function
pairwise_penalty <- function(beta, lambda_1 = 1, lambda_2 = 1) {
L1 <- p_norm(beta, 1) * lambda_1
p <- beta@dim[1]
pair_indices <- combn(p, 2, simplify = FALSE)
browser()
# Create penalty matrix: each row enforces β_j - β_k
penalty_matrix <- do.call(rbind, lapply(pair_indices, function(idx) {
vec <- rep(0, p)
vec[idx[1]] <- 1
vec[idx[2]] <- -1
vec
}))
fusionPenalty <- sum(abs(penalty_matrix %*% beta)) * lambda_2
L1 + fusionPenalty
}
pairwise_penalty(beta, lambda_1, lambda_2)
pairwise_penalty(beta, lambda_1, lambda_2)
L1
obj <- binomLoss + pairwise_penalty(beta, lambda_1, lambda_2)
prob <- Problem(Minimize(obj))
## Solving
result <- solve(prob)
pairwise_penalty(beta, lambda_1, lambda_2)
View(penalty_matrix)
View(fusionPenalty)
prob <- Problem(Minimize(obj))
## Solving
result <- solve(prob)
View(beta)
## Penalty Function
pairwise_penalty <- function(beta, lambda_1 = 1, lambda_2 = 1) {
L1 <- p_norm(beta, 1) * lambda_1
p <- beta@dim[1]
pair_indices <- combn(p, 2, simplify = FALSE)
browser()
# Create penalty matrix: each row enforces β_j - β_k
# penalty_matrix <- do.call(rbind, lapply(pair_indices, function(idx) {
#   vec <- rep(0, p)
#   vec[idx[1]] <- 1
#   vec[idx[2]] <- -1
#   vec
# }))
# fusionPenalty <- sum(abs(penalty_matrix %*% beta)) * lambda_2
fusionPenalty <- do.call(sum, lapply(pair_indices, function(idx) {
abs(beta[pair_indices[1]] - beta[pair_indices[2]])
}))
fusionPenalty <- fusionPenalty * lambda_2
L1 + fusionPenalty
}
pairwise_penalty(beta, lambda_1, lambda_2)
## Solving
try(result <- solve(prob))
## Solving
try({
result <- solve(prob)
## Inspect Results
betaEst <- result$getValue(beta)
plot(1:p, sort(betaEst))
})
?PMA::SPC
